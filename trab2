


#define _GNU_SOURCE
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <sched.h>
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>
// 64kB stack
#define FIBER_STACK 1024*64
#define thread 200
#define LEFT (i+thread-1)%thread
#define RIGHT (i+1)%thread
///////////////////
pthread_t filosofo[thread];	// threads para cada filC3sofo
sem_t garfo[thread];		// semC!foros para cada garfo
sem_t mutex;
///////////////////
struct c
{
  int saldo;
};
typedef struct c conta;
conta from, to;
int valor;

// The child thread will execute this function
void *
transferencia (void *arg)
{
  int i = *(int *) arg;
  while (1)
    {

      sleep (rand () % 5);
      sem_wait (&mutex);
      sem_wait (&garfo[LEFT]);
      sem_wait (&garfo[RIGHT]);
      if (from.saldo >= valor)
	{			// 2

	  from.saldo -= valor;
	  to.saldo += valor;
	  printf ("TransferC*ncia concluC-da com sucesso!\n");
	  printf ("Saldo de c1: %d\n", from.saldo);
	  printf ("Saldo de c2: %d\n", to.saldo);
	}

      sem_post (&garfo[RIGHT]);
      sem_post (&garfo[LEFT]);
      sem_post (&mutex);
      pthread_exit (NULL);
    }
  
}



int
main ()
{
  void *stack;
  pid_t pid;
  int i;
  stack = malloc (FIBER_STACK);
  from.saldo = 200;
  to.saldo = 200;
  printf ("Transferindo 10 para a conta c2\n");
  valor = 1;

  int id[thread];
  sem_init (&mutex, 0, 1);	// inicializa semC!foro mutex
  for (i = 0; i < thread; i++)
    {
      sem_init (&garfo[i], 0, 1);	// inicializa semC!foro de cada garfo
    }
  for (i = 0; i < thread; i++)
    {
      id[i] = i;
      pthread_create (&filosofo[i], NULL, transferencia, (void *) &id[i]);	// cria thread para cada filC3sofo
    }
  for (i = 0; i < thread; i++)
    {
      pthread_join (filosofo[i], NULL);	// aguarda tC)rmino das threads
    }
  return 0;


  free (stack);
  printf ("TransferC*ncias concluC-das e memC3ria liberada.\n");

  return 0;
}
