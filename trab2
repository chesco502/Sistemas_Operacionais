

#define _GNU_SOURCE
#include <stdlib.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <sched.h>
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>
// 64kB stack
#define FIBER_STACK 1024*64
#define thread 10
#define LEFT (i+N-1)%N 
#define RIGHT (i+1)%N
///////////////////
pthread_t filosofo[thread]; // threads para cada filósofo
sem_t garfo[thread]; // semáforos para cada garfo
sem_t mutex;
///////////////////
struct c
{
  int saldo;
};
typedef struct c conta;
conta from, to;
int valor;

// The child thread will execute this function
void
*transferencia (void *arg)
{
 
  
 
  if (from.saldo >= valor)
     {				// 2
      
      from.saldo -= valor;
      to.saldo += valor;
    }
  printf ("TransferC*ncia concluC-da com sucesso!\n");
  printf ("Saldo de c1: %d\n", from.saldo);
  printf ("Saldo de c2: %d\n", to.saldo);
  return 0;
}

int
main ()
{
  void *stack;
  pid_t pid;
  int i;
  stack = malloc (FIBER_STACK);
  from.saldo = 200;
  to.saldo = 200;
  printf ("Transferindo 10 para a conta c2\n");
  valor = 10;
  
    int  id[thread];
    sem_init(&mutex, 0, 1); // inicializa semáforo mutex
    for (i = 0; i < thread; i++) {
        sem_init(&garfo[i], 0, 1); // inicializa semáforo de cada garfo
    }
    for (i = 0; i < thread; i++) {
        id[i] = i;
        pthread_create(&filosofo[i], NULL,transferencia , (void *) &id[i]); // cria thread para cada filósofo
    }
    for (i = 0; i < thread; i++) {
        pthread_join(filosofo[i], NULL); // aguarda término das threads
    }
    return 0;

  
  free (stack);
  printf ("TransferC*ncias concluC-das e memC3ria liberada.\n");
  
  return 0;
}
